{% extends 'todo/base.html' %}

{% block title %}Todo List{% endblock %}

{% block content %}
<div class="d-flex justify-content-between align-items-center mb-4">
    <h1>Todo List</h1>
    <div class="d-flex gap-2">
        <a href="{% url 'task_report' %}" class="btn btn-info">View Task Report</a>
        <button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#createTaskModal">
            Create Task
        </button>
    </div>
</div>

<!-- Create Task Modal -->
<div class="modal fade" id="createTaskModal" tabindex="-1" aria-labelledby="createTaskModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="createTaskModalLabel">Create New Task</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="createTaskForm">
                    {% csrf_token %}
                    <div class="mb-3">
                        <label for="id_title_modal" class="form-label">Title</label>
                        <input type="text" name="title" class="form-control" id="id_title_modal" required>
                        <div class="invalid-feedback" id="error_title_modal"></div>
                    </div>
                    <div class="mb-3">
                        <label for="id_description_modal" class="form-label">Description</label>
                        <textarea name="description" class="form-control" id="id_description_modal" rows="3"></textarea>
                        <div class="invalid-feedback" id="error_description_modal"></div>
                    </div>
                    <div class="mb-3">
                        <label for="id_task_date_modal" class="form-label">Task Date</label>
                        <input type="date" name="task_date" class="form-control" id="id_task_date_modal">
                        <div class="invalid-feedback" id="error_task_date_modal"></div>
                    </div>
                    <div class="mb-3">
                        <label for="id_time_spent_hours_modal" class="form-label">Time Spent (hours)</label>
                        <input type="number" step="0.1" name="time_spent_hours" class="form-control" id="id_time_spent_hours_modal" placeholder="e.g., 1.5">
                        <div class="invalid-feedback" id="error_time_spent_hours_modal"></div>
                    </div>
                    <div class="mb-3">
                        <label for="id_status_modal" class="form-label">Status</label>
                        <select name="status" class="form-select" id="id_status_modal">
                            <option value="todo">To Do</option>
                            <option value="inprogress">In Progress</option>
                            <option value="done">Done</option>
                        </select>
                        <div class="invalid-feedback" id="error_status_modal"></div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        <button type="submit" class="btn btn-primary">Save Task</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Search Form -->
<form method="get" action="{% url 'todo_list' %}" class="mb-3">
    <div class="input-group">
        <input type="text" name="q" class="form-control" placeholder="Search tasks..." value="{{ request.GET.q | default:'' }}">
        <button class="btn btn-outline-secondary" type="submit">Search</button>
    </div>
</form>

<table class="table table-striped table-hover align-middle">
    <thead>
        <tr>
            <th>
                <a href="?order_by={% if request.GET.order_by == 'title' %}-title{% else %}title{% endif %}&q={{ request.GET.q | default:'' }}">
                    Title {% if request.GET.order_by == 'title' %}▲{% elif request.GET.order_by == '-title' %}▼{% endif %}
                </a>
            </th>
            <th>Description</th> {# Assuming description is not a primary sort field #}
            <th>Time Spent (hours)</th>
            <th>
                <a href="?order_by={% if request.GET.order_by == 'task_date' %}-task_date{% else %}task_date{% endif %}&q={{ request.GET.q | default:'' }}">
                    Task Date {% if request.GET.order_by == 'task_date' %}▲{% elif request.GET.order_by == '-task_date' %}▼{% endif %}
                </a>
            </th>
            <th>
                <a href="?order_by={% if request.GET.order_by == 'status' %}-status{% else %}status{% endif %}&q={{ request.GET.q | default:'' }}">
                    Status {% if request.GET.order_by == 'status' %}▲{% elif request.GET.order_by == '-status' %}▼{% endif %}
                </a>
            </th>
            <th>Actions</th>
        </tr>
    </thead>
    <tbody>
        {% for todo in page_obj %}  {# Use page_obj here #}
        <tr data-id="{{ todo.id }}">
            <td data-field="title"><b><a href="{% url 'todo_detail' todo.id %}">{{ todo.title }}</a></b></td>
            <td data-field="description">{{ todo.description }}</td>
            <td data-field="time_spent">{{ todo.time_spent_hours|floatformat:2 }}h</td>
            <td data-field="task_date">{{ todo.task_date|date:"Y-m-d"|default:"N/A" }}</td>
            <td data-field="status" data-value="{{ todo.status }}">
                {% if todo.status == 'done' %}
                    <span class="badge bg-success">{{ todo.get_status_display }}</span>
                {% elif todo.status == 'inprogress' %}
                    <span class="badge bg-primary">{{ todo.get_status_display }}</span>
                {% else %}
                    <span class="badge bg-warning text-dark">{{ todo.get_status_display }}</span>
                {% endif %}
            </td>
            <td>
                <button type="button" class="btn btn-sm btn-outline-primary me-1 inline-edit-btn">Inline Edit</button>
                <a href="{% url 'edit_todo' todo.id %}" class="btn btn-sm btn-outline-secondary">Edit Page</a>
                <button class="btn btn-sm btn-danger delete-todo-btn" data-todo-id="{{ todo.id }}" data-delete-url="{% url 'delete_todo' todo.id %}">Delete</button>
            </td>
        </tr>
        {% empty %}
        <tr>
            <td colspan="6" class="text-center text-muted">
                You have no tasks yet. <a href="{% url 'add_todo' %}">Add one!</a>
            </td>
        </tr>
        {% endfor %}
    </tbody>
</table>

<!-- Pagination -->
<nav aria-label="Page navigation">
    <ul class="pagination justify-content-center">
        {% if page_obj.has_previous %}
            <li class="page-item"><a class="page-link" href="?page=1&q={{ request.GET.q | default:'' }}&order_by={{ request.GET.order_by | default:'task_date' }}">&laquo; First</a></li>
            <li class="page-item"><a class="page-link" href="?page={{ page_obj.previous_page_number }}&q={{ request.GET.q | default:'' }}&order_by={{ request.GET.order_by | default:'task_date' }}">Previous</a></li>
        {% else %}
            <li class="page-item disabled"><span class="page-link">&laquo; First</span></li>
            <li class="page-item disabled"><span class="page-link">Previous</span></li>
        {% endif %}

        <li class="page-item disabled"><span class="page-link">Page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }}</span></li>

        {% if page_obj.has_next %}
            <li class="page-item"><a class="page-link" href="?page={{ page_obj.next_page_number }}&q={{ request.GET.q | default:'' }}&order_by={{ request.GET.order_by | default:'task_date' }}">Next</a></li>
            <li class="page-item"><a class="page-link" href="?page={{ page_obj.paginator.num_pages }}&q={{ request.GET.q | default:'' }}&order_by={{ request.GET.order_by | default:'task_date' }}">Last &raquo;</a></li>
        {% else %}
            <li class="page-item disabled"><span class="page-link">Next</span></li>
            <li class="page-item disabled"><span class="page-link">Last &raquo;</span></li>
        {% endif %}
    </ul>
</nav>

{% csrf_token %} {# For AJAX POST requests #}

<script>
document.addEventListener('DOMContentLoaded', function () {
    const tableBody = document.querySelector('.table tbody');
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value; // General CSRF for inline edit

    // --- Create Task Modal Logic ---
    const createTaskModal = new bootstrap.Modal(document.getElementById('createTaskModal'));
    const createTaskForm = document.getElementById('createTaskForm');
    const createCsrfToken = createTaskForm.querySelector('[name=csrfmiddlewaretoken]').value; // CSRF for create form

    createTaskForm.addEventListener('submit', function(event) {
        event.preventDefault();
        clearCreateFormErrors();

        const formData = new FormData(createTaskForm);
        // The 'completed' field is being phased out in favor of 'status'.
        // If your backend still uses 'completed', you might need to derive it from 'status'.
        // For now, we'll assume 'status' is the primary field.
        // formData.set('completed', formData.get('status') === 'done' ? 'true' : 'false');


        // Convert FormData to a plain object for JSON stringification
        const data = {};
        formData.forEach((value, key) => {
            if (key === 'csrfmiddlewaretoken') return;

            // Example: Deriving 'completed' if necessary for backend compatibility
            // if (key === 'status' && value === 'done') {
            //    data['completed'] = true;
            // } else if (key === 'status' && value !== 'done') {
            //    data['completed'] = false;
            // }

            if (key === 'time_spent_hours') {
                data[key] = value ? parseFloat(value) : null;
            } else if (key === 'task_date') {
                 data[key] = value ? value : null;
            }
            // Ensure 'completed' is explicitly set based on 'status' if it's still used by the backend logic for creation.
            // Otherwise, if 'completed' is fully removed from the model or handled by 'status' on save, this is not needed.
            else {
                data[key] = value;
            }
        });
        // Ensure 'completed' is derived from status if it's still part of the form submission expected by the view for 'add_todo'
        // This depends on how the 'add_todo' view and 'TodoForm' handle the 'completed' field.
        // If TodoForm still has 'completed', it might be auto-set by status, or it needs to be sent.
            // For the purpose of this update, we assume 'status' is the source of truth.


        fetch("{% url 'add_todo' %}", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': createCsrfToken, // Use the token from the create form
                'X-Requested-With': 'XMLHttpRequest' // To help Django identify AJAX
            },
            body: JSON.stringify(data)
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(errData => {
                    throw { status: response.status, data: errData };
                });
            }
            return response.json();
        })
        .then(result => {
            if (result.success) {
                addTodoToTable(result.todo);
                createTaskModal.hide();
                createTaskForm.reset();
                // Optionally, show a success message (e.g., using a toast)
            } else if (result.errors) {
                // This case should be caught by the !response.ok check if status is 400
                displayCreateFormErrors(result.errors);
            }
        })
        .catch(errorInfo => {
            console.error('Error creating task:', errorInfo);
            if (errorInfo.status === 400 && errorInfo.data && errorInfo.data.errors) {
                const errors = JSON.parse(errorInfo.data.errors); // errors are JSON string
                displayCreateFormErrors(errors);
            } else if (errorInfo.data && errorInfo.data.error) {
                 // Generic error from server not related to form fields
                alert('Error: ' + errorInfo.data.error);
            }
            else {
                alert('An unexpected error occurred while creating the task. Please try again.');
            }
        });
    });

    function clearCreateFormErrors() {
        createTaskForm.querySelectorAll('.invalid-feedback').forEach(el => el.textContent = '');
        createTaskForm.querySelectorAll('.form-control, .form-check-input').forEach(el => el.classList.remove('is-invalid'));
    }

    function displayCreateFormErrors(errors) {
        for (const fieldName in errors) {
            const errorMessages = errors[fieldName].map(e => e.message).join(', ');
            const field = createTaskForm.querySelector(`[name="${fieldName}"]`);
            const errorDiv = createTaskForm.querySelector(`#error_${fieldName}_modal`); // e.g. #error_title_modal

            if (field) {
                field.classList.add('is-invalid');
            }
            if (errorDiv) {
                errorDiv.textContent = errorMessages;
            } else {
                // Fallback if a specific error div isn't found for a field (e.g. non_field_errors)
                // Or display a general error message at the top of the modal
                const generalErrorDiv = createTaskForm.querySelector('#general_create_errors_modal'); // You'd need to add this div to the modal
                if (generalErrorDiv) generalErrorDiv.textContent += `${fieldName}: ${errorMessages}\n`;
                else alert(`Error for ${fieldName}: ${errorMessages}`); // Fallback
            }
        }
    }

    function addTodoToTable(todo) {
        const newRow = tableBody.insertRow(0); // Insert at the top or use appendRow for bottom
        newRow.dataset.id = todo.id;

        const titleHtml = `<b><a href="/todo_detail/${todo.id}/">${todo.title}</a></b>`;
        let statusHtml;
        let statusValue = todo.status || 'todo'; // Default to 'todo' if undefined
        let statusText = todo.get_status_display || 'To Do'; // Default text

        // Assuming todo.status gives 'todo', 'inprogress', 'done'
        // and todo.get_status_display gives the human-readable form.
        // If result.todo from AJAX is raw, we need to map it:
        const statusDisplayMap = {
            'todo': 'To Do',
            'inprogress': 'In Progress',
            'done': 'Done'
        };
        statusText = statusDisplayMap[statusValue] || 'To Do';


        if (statusValue === 'done') {
            statusHtml = `<span class="badge bg-success">${statusText}</span>`;
        } else if (statusValue === 'inprogress') {
            statusHtml = `<span class="badge bg-primary">${statusText}</span>`;
        } else { // todo
            statusHtml = `<span class="badge bg-warning text-dark">${statusText}</span>`;
        }
        newRow.setAttribute('data-value', statusValue); // Set data-value on the <tr> or status <td> for consistency

        const taskDateDisplay = todo.task_date ? new Date(todo.task_date + 'T00:00:00').toLocaleDateString('en-CA') : "N/A"; // Format to YYYY-MM-DD or N/A
        const timeSpentDisplay = todo.time_spent_hours != null ? `${parseFloat(todo.time_spent_hours).toFixed(2)}h` : "0.00h";

        newRow.innerHTML = `
            <td data-field="title">${titleHtml}</td>
            <td data-field="description">${todo.description || ''}</td>
            <td data-field="time_spent">${timeSpentDisplay}</td>
            <td data-field="task_date">${taskDateDisplay}</td>
            <td data-field="status">${statusHtml}</td>
            <td>
                <button type="button" class="btn btn-sm btn-outline-primary me-1 inline-edit-btn">Inline Edit</button>
                <a href="/todo/${todo.id}/edit/" class="btn btn-sm btn-outline-secondary">Edit Page</a>
                <a href="/delete_todo/${todo.id}/" class="btn btn-sm btn-danger">Delete</a>
            </td>
        `;
        // If there's an "empty" message row, remove it
        const emptyRow = tableBody.querySelector('tr td[colspan="6"]');
        if (emptyRow) {
            emptyRow.parentElement.remove();
        }
    }

    // --- End Create Task Modal Logic ---

    // Combined event listener for table body
    tableBody.addEventListener('click', function (event) {
        const target = event.target;
        const row = target.closest('tr');

        if (!row || !row.dataset.id) { // Check if click is on a valid row
             // Handle delete button click specifically, as it might be the only button on the row
            if (target.classList.contains('delete-todo-btn')) {
                event.preventDefault();
                const todoId = target.dataset.todoId;
                const deleteUrl = target.dataset.deleteUrl;
                const specificRowToRemove = target.closest('tr'); // a more specific row for removal

                Swal.fire({
                    title: 'Are you sure?',
                    text: "You won't be able to revert this!",
                    icon: 'warning',
                    showCancelButton: true,
                    confirmButtonColor: '#d33',
                    cancelButtonColor: '#3085d6',
                    confirmButtonText: 'Yes, delete it!'
                }).then((result) => {
                    if (result.isConfirmed) {
                        fetch(deleteUrl, {
                            method: 'POST',
                            headers: {
                                'X-CSRFToken': csrfToken, // Defined above
                                'X-Requested-With': 'XMLHttpRequest'
                            }
                        })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(err => { throw err; });
                            }
                            return response.json();
                        })
                        .then(data => {
                            if (data.success) {
                                if (specificRowToRemove) specificRowToRemove.remove();
                                Swal.fire('Deleted!','Your task has been deleted.','success');
                                if (tableBody.querySelectorAll('tr').length === 0) {
                                    const emptyMessageHtml = `
                                        <tr>
                                            <td colspan="6" class="text-center text-muted">
                                                You have no tasks yet. <a href="{% url 'add_todo' %}">Add one!</a>
                                            </td>
                                        </tr>`;
                                    tableBody.innerHTML = emptyMessageHtml;
                                }
                            } else {
                                Swal.fire('Failed!', data.error || 'Could not delete the task.', 'error');
                            }
                        })
                        .catch(error => {
                            console.error('Error deleting task:', error);
                            Swal.fire('Error!', error.error || 'An unexpected error occurred.', 'error');
                        });
                    }
                });
            } // End of delete button logic
            return; // If not on a valid row and not delete button, do nothing
        }


        // If we are on a valid row (row && row.dataset.id is true)
        const todoId = row.dataset.id;

        // Handle "Inline Edit" button click
        if (target.classList.contains('inline-edit-btn')) {
            if (row.classList.contains('editing')) return; // Already editing
            enterEditMode(row, target);
        }
        // Handle "Save" button click
        else if (target.classList.contains('save-btn')) {
            saveChanges(row, todoId);
        }
        // Handle "Cancel" button click
        else if (target.classList.contains('cancel-btn')) {
            cancelEditMode(row);
        }
        // Handle "Delete" button click (if missed by the above specific check, e.g. if row.dataset.id was initially null but button is valid)
        // This is a fallback, the primary check for delete is above.
        else if (target.classList.contains('delete-todo-btn')) {
             event.preventDefault();
            const deleteUrl = target.dataset.deleteUrl;
            // const specificRowToRemove = target.closest('tr'); // Already have 'row'

            Swal.fire({
                title: 'Are you sure?',
                text: "You won't be able to revert this!",
                icon: 'warning',
                showCancelButton: true,
                confirmButtonColor: '#d33',
                cancelButtonColor: '#3085d6',
                confirmButtonText: 'Yes, delete it!'
            }).then((result) => {
                if (result.isConfirmed) {
                    fetch(deleteUrl, {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': csrfToken,
                            'X-Requested-With': 'XMLHttpRequest'
                        }
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            if (row) row.remove(); // Use current row
                            Swal.fire('Deleted!','Your task has been deleted.','success');
                             if (tableBody.querySelectorAll('tr').length === 0) {
                                const emptyMessageHtml = `
                                    <tr>
                                        <td colspan="6" class="text-center text-muted">
                                            You have no tasks yet. <a href="{% url 'add_todo' %}">Add one!</a>
                                        </td>
                                    </tr>`;
                                tableBody.innerHTML = emptyMessageHtml;
                            }
                        } else {
                            Swal.fire('Failed!', data.error || 'Could not delete the task.', 'error');
                        }
                    })
                    .catch(error => {
                        Swal.fire('Error!', 'An unexpected error occurred.', 'error');
                    });
                }
            });
        }
    });

    function enterEditMode(row, editButton) {
        row.classList.add('editing');
        row.dataset.originalHtml = {}; // Store original values for cancel

        // Title
        const titleCell = row.querySelector('td[data-field="title"]');
        const titleLink = titleCell.querySelector('a');
        const currentTitle = titleLink ? titleLink.textContent : titleCell.textContent.trim();
        row.dataset.originalHtmlTitle = titleCell.innerHTML;
        titleCell.innerHTML = `<input type="text" class="form-control form-control-sm" value="${currentTitle}">`;

        // Description
        const descriptionCell = row.querySelector('td[data-field="description"]');
        const currentDescription = descriptionCell.textContent.trim();
        row.dataset.originalHtmlDescription = descriptionCell.innerHTML;
        descriptionCell.innerHTML = `<textarea class="form-control form-control-sm">${currentDescription}</textarea>`;

        // Time Spent (hours)
        const timeCell = row.querySelector('td[data-field="time_spent"]');
        const currentTimeText = timeCell.textContent.trim().replace('h', '');
        const currentTime = parseFloat(currentTimeText) || 0;
        row.dataset.originalHtmlTime = timeCell.innerHTML;
        timeCell.innerHTML = `<input type="number" step="0.1" class="form-control form-control-sm" value="${currentTime}">`;

        // Task Date
        const taskDateCell = row.querySelector('td[data-field="task_date"]');
        const currentTaskDate = taskDateCell.textContent.trim();
        // Ensure the value is in YYYY-MM-DD for the input type="date"
        // The existing display format is "Y-m-d", which is compatible.
        const taskDateForInput = currentTaskDate === "N/A" ? "" : currentTaskDate;
        row.dataset.originalHtmlTaskDate = taskDateCell.innerHTML;
        taskDateCell.innerHTML = `<input type="date" class="form-control form-control-sm" value="${taskDateForInput}">`;

        // Status
        const statusCell = row.querySelector('td[data-field="status"]');
        const currentStatusValue = statusCell.dataset.value; // 'todo', 'inprogress', 'done'
        row.dataset.originalHtmlStatus = statusCell.innerHTML;
        statusCell.innerHTML = `
            <select class="form-select form-select-sm">
                <option value="todo" ${currentStatusValue === 'todo' ? 'selected' : ''}>To Do</option>
                <option value="inprogress" ${currentStatusValue === 'inprogress' ? 'selected' : ''}>In Progress</option>
                <option value="done" ${currentStatusValue === 'done' ? 'selected' : ''}>Done</option>
            </select>`;

        // Change buttons
        const actionsCell = editButton.closest('td');
        row.dataset.originalHtmlActions = actionsCell.innerHTML;
        actionsCell.innerHTML = `
            <button type="button" class="btn btn-sm btn-success me-1 save-btn">Save</button>
            <button type="button" class="btn btn-sm btn-warning cancel-btn">Cancel</button>
        `;
    }

    function exitEditMode(row, newValues) {
        row.classList.remove('editing');

        // Title
        const titleCell = row.querySelector('td[data-field="title"]');
        // Retain link structure if it was there
        const originalTitleHTML = row.dataset.originalHtmlTitle;
        if (originalTitleHTML && originalTitleHTML.includes('<a href')) {
            const link = document.createElement('a');
            link.href = originalTitleHTML.match(/href="([^"]*)"/)[1]; // Extract href
            link.innerHTML = `<b>${newValues.title}</b>`;
            titleCell.innerHTML = ''; // Clear existing input
            titleCell.appendChild(link);
        } else {
            titleCell.innerHTML = `<b>${newValues.title}</b>`;
        }


        // Description
        const descriptionCell = row.querySelector('td[data-field="description"]');
        descriptionCell.textContent = newValues.description;

        // Time Spent
        const timeCell = row.querySelector('td[data-field="time_spent"]');
        timeCell.textContent = `${parseFloat(newValues.time_spent_hours).toFixed(2)}h`;

        // Task Date
        const taskDateCell = row.querySelector('td[data-field="task_date"]');
        // Format date as YYYY-MM-DD or show N/A
        let displayTaskDate = "N/A";
        if (newValues.task_date) {
            // Assuming newValues.task_date is in 'YYYY-MM-DD' format from the server
            displayTaskDate = newValues.task_date;
        }
        taskDateCell.textContent = displayTaskDate;

        // Status
        const statusCell = row.querySelector('td[data-field="status"]');
        const newStatusValue = newValues.status;
        statusCell.dataset.value = newStatusValue; // Update data-value for future edits
        let statusBadgeHtml;
        // Assuming newValues.get_status_display is available or we map it
        const statusDisplayMap = {
            'todo': 'To Do',
            'inprogress': 'In Progress',
            'done': 'Done'
        };
        const newStatusDisplay = newValues.get_status_display || statusDisplayMap[newStatusValue];

        if (newStatusValue === 'done') {
            statusBadgeHtml = `<span class="badge bg-success">${newStatusDisplay}</span>`;
        } else if (newStatusValue === 'inprogress') {
            statusBadgeHtml = `<span class="badge bg-primary">${newStatusDisplay}</span>`;
        } else { // todo
            statusBadgeHtml = `<span class="badge bg-warning text-dark">${newStatusDisplay}</span>`;
        }
        statusCell.innerHTML = statusBadgeHtml;

        // Restore original action buttons
        const actionsCell = row.querySelector('td:last-child'); // Assuming actions are always last
        actionsCell.innerHTML = row.dataset.originalHtmlActions;

        // Clean up stored original HTML
        delete row.dataset.originalHtmlTitle;
        delete row.dataset.originalHtmlDescription;
        delete row.dataset.originalHtmlTime;
        delete row.dataset.originalHtmlTaskDate; // Clean up task_date
        delete row.dataset.originalHtmlStatus;
        delete row.dataset.originalHtmlActions;
    }

    function cancelEditMode(row) {
        row.classList.remove('editing');
        // Restore original HTML content for each cell
        row.querySelector('td[data-field="title"]').innerHTML = row.dataset.originalHtmlTitle;
        row.querySelector('td[data-field="description"]').innerHTML = row.dataset.originalHtmlDescription;
        row.querySelector('td[data-field="time_spent"]').innerHTML = row.dataset.originalHtmlTime;
        row.querySelector('td[data-field="task_date"]').innerHTML = row.dataset.originalHtmlTaskDate; // Restore task_date
        row.querySelector('td[data-field="status"]').innerHTML = row.dataset.originalHtmlStatus;
        row.querySelector('td:last-child').innerHTML = row.dataset.originalHtmlActions; // Action buttons

        // Clean up stored original HTML
        delete row.dataset.originalHtmlTitle;
        delete row.dataset.originalHtmlDescription;
        delete row.dataset.originalHtmlTime;
        delete row.dataset.originalHtmlTaskDate; // Clean up task_date
        delete row.dataset.originalHtmlStatus;
        delete row.dataset.originalHtmlActions;
    }

    function saveChanges(row, todoId) {
        const title = row.querySelector('td[data-field="title"] input').value;
        const description = row.querySelector('td[data-field="description"] textarea').value;
        const time_spent_hours = parseFloat(row.querySelector('td[data-field="time_spent"] input').value);
        const task_date_input = row.querySelector('td[data-field="task_date"] input').value;
        // Send null if date is empty, otherwise send the date string.
        // The backend (Django ModelForm/DateField) will handle conversion to None if appropriate.
        const task_date = task_date_input ? task_date_input : null;
        const status = row.querySelector('td[data-field="status"] select').value; // 'todo', 'inprogress', 'done'


        const data = {
            title: title,
            description: description,
            time_spent_hours: time_spent_hours,
            task_date: task_date,
            status: status, // Send status
        };
        // If your backend for inline_edit specifically needs 'completed', this is where it would be derived.
        // However, since we are removing 'completed' functionality, this is no longer needed.
        // For consistency with the plan, we assume the backend will handle 'status'.

        fetch(`/todo/inline_edit/${todoId}/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
            },
            body: JSON.stringify(data),
        })
        .then(response => {
            if (!response.ok) {
                // Try to get error message from server if JSON, otherwise use status text
                return response.json().then(errData => {
                    throw new Error(errData.error || response.statusText);
                }).catch(() => { // Catch if response.json() fails (not JSON error)
                    throw new Error(`Server error: ${response.status} ${response.statusText}`);
                });
            }
            return response.json();
        })
        .then(result => {
            if (result.success) {
                // The server should return the processed data, including time_spent_hours
                exitEditMode(row, result.todo);
            } else {
                alert('Error saving changes: ' + (result.error || 'Unknown error'));
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Failed to save changes: ' + error.message);
            // Optionally, revert to original values or keep inputs for user to retry
        });
    }
});
</script>
{% endblock %}